Voices
======

Making a voice from a LilyPond input string
-------------------------------------------

You can make an Abjad voice from a LilyPond input string:

<abjad>
voice = Voice("c'8 d'8 e'8 f'8 g'8 a'8 b'4 c''1")
</abjad>

<abjad>
show(voice)
iotools.write_expr_to_ly(voice, 'voices-1') <hide
</abjad>

Making a voice from a list of other Abjad components
----------------------------------------------------

You can also make a voice from a list of other Abjad components:

<abjad>
components = [Tuplet(Fraction(2, 3), "c'4 d'4 e'4"), Note("f'2"), Note("g'1")]
</abjad>

<abjad>
voice = Voice(components)
</abjad>

<abjad>
show(voice)
iotools.write_expr_to_ly(voice, 'voices-2') <hide
</abjad>

Understanding the ``repr`` of a voice
-------------------------------------

The ``repr`` of an Abjad voice contains three parts:

<abjad>
voice
print repr(voice) <hide
</abjad>

``Voice`` tells you the voice's class.

``3`` tells you the voice's length (which is the number of
top-level components the voice contains).

Curly braces ``{`` and ``}`` tell you that the music inside the voice is
interpreted sequentially rather than in parallel.

Inspecting the LilyPond format of a voice
-----------------------------------------

Get the LilyPond input format of any Abjad object with ``format``:

<abjad>
voice.format
print repr(voice.format) <hide
</abjad>

Use ``f()`` as a short-cut to print the LilyPond format of any Abjad object:

<abjad>
f(voice)
</abjad>

Inspecting the music in a voice
-------------------------------

Get voice components with ``music``:

<abjad>
voice.music
print repr(voice.music) <hide
</abjad>

Abjad returns a read-only tuple of components.

Inspecting a voice's leaves
---------------------------

Get the leaves in a voice with ``leaves``:

<abjad>
voice.leaves
print repr(voice.leaves) <hide
</abjad>

Abjad returns a read-only tuple of leaves.

Getting the length of a voice
-----------------------------

Get voice length with ``len()``:

<abjad>
len(voice)
print repr(len(voice)) <hide
</abjad>

The length of a voice is defined equal to the number of
top-level components the voice contains.

Getting the duration attributes of a voice
------------------------------------------

The contents durations of a voice equals the sum of durations of the components in the voice:

<abjad>
voice.contents_duration
print repr(voice.contents_duration) <hide
</abjad>

The preprolated duration of a voice is usually equal to the voice's contents duration:

<abjad>
voice.preprolated_duration
print repr(voice.preprolated_duration) <hide
</abjad>

The prolated duration of a voice is usually equal to the voice's contents duration, too:

<abjad>
voice.preprolated_duration
print repr(voice.preprolated_duration) <hide
</abjad>

Only when you nest a very small voice inside a tuplet will the prolated and
preprolated duration of a voice differ.

Voices that are not nested inside a tuplet carry a prolation of ``1``:

<abjad>
voice.prolation
print repr(voice.prolation) <hide
</abjad>

All voice duration attributes are read-only.

Adding one component to the end of a voice
------------------------------------------

Add one component to the end of a voice with ``append``:

<abjad>
voice.append(Note("af'2"))
</abjad>

<abjad>
show(voice)
iotools.write_expr_to_ly(voice, 'voices-3') <hide
</abjad>

Adding many components to the end of a voice
--------------------------------------------

Add many components to the end of a voice with ``extend``:

<abjad>
notes = [Note("g'4"), Note("f'4")]
voice.extend(notes)
</abjad>

<abjad>
show(voice)
iotools.write_expr_to_ly(voice, 'voices-4') <hide
</abjad>

Finding the index of a component in a voice
-------------------------------------------

Find the index of a component in a voice with ``index()``:

<abjad>
notes[0]
print repr(notes[0]) <hide
</abjad>

<abjad>
voice.index(notes[0])
print repr(voice.index(notes[0])) <hide
</abjad>

Removing a voice component by index
-----------------------------------

Use ``pop()`` to remove a voice component by index:

<abjad>
voice[5]
print repr(voice[5]) <hide
</abjad>

<abjad>
voice.pop(5)
</abjad>

<abjad>
show(voice)
iotools.write_expr_to_ly(voice, 'voices-5') <hide
</abjad>

Removing a voice component by reference
---------------------------------------

Remove voice components by reference with ``remove()``:

<abjad>
voice.remove(voice[-1])
</abjad>

<abjad>
show(voice)
iotools.write_expr_to_ly(voice, 'voices-6') <hide
</abjad>

Naming voices
-------------

You can name Abjad voices:

<abjad>
voice.name = 'Upper Voice'
</abjad>

Voice names appear in LilyPond input:

<abjad>
f(voice)
</abjad>

But not in notational output:

<abjad>
show(voice)
iotools.write_expr_to_ly(voice, 'voices-7') <hide
</abjad>

Changing the context of a voice
-------------------------------

The context of a voice is set to ``'Voice'`` by default:

<abjad>
voice.context
print repr(voice.context) <hide
</abjad>

But you can change the context of a voice if you want:

<abjad>
voice.context = 'SpeciallyDefinedVoice'
</abjad>

<abjad>
voice.context
print repr(voice.context) <hide
</abjad>

<abjad>
f(voice)
</abjad>

Change the context of a voice when you have defined
a new LilyPond context based on a LilyPond voice.
