Working with threads
====================


What is a thread?
-----------------

A thread is a structural relationship binding a set of strictly sequential voice-level components.

Threads may be explicitly defined via voice instances:

<abjad>
v = Voice()
</abjad>

Or they may exist implicitly in certain score constructs in the absence of voice containers:

<abjad>
staff = Staff("c'8 d'8 e'8 f'8")
</abjad>

Two contiguous voices must have the same name in order to be part of the same thread.

Here a thread does **not** exist between notes in different voices:

<abjad>
v_one = Voice("c'16 d'16 e'16 f'16")
v_two = Voice("c'8 d'8")
staff = Staff([v_one, v_two])
f(staff)
</abjad>

Here a thread does exist:

<abjad>
v_one.name = 'flute'
v_two.name = 'flute'
f(staff)
</abjad>

What are threads for?
---------------------

Consider the following situation:

.. image:: images/thread-resolution-1.png

Are the two eighth notes in the second half of the measure the continuation
of the ascending line in the first half, or is it the quarter note?
Is the very last *C* the continuation of the top melodic line or is it the *A*?
The stems might suggest an answer, but for Abjad, stem direction is not structural.
What path should Abjad take to traverse this little score from the first note to the last *A*?
This same problem appears when trying to apply spanners to parallel structures.
Thus, threads are important in both score navigation and the application of spanners.
In fact, threads are a requirement for spanner application.

In Abjad, the ambiguity is resolved through the explicit use of named voices.

The musical fragment above is constructed with the following code:

<abjad>
vA = Voice(notetools.make_notes([5, 7, 9, 11], [(1, 8)] * 4))
vB = Voice(notetools.make_notes([12, 11, 9], [(1, 8), (1, 8), (1, 4)]))
vC = Voice(Note(12, (1, 4)) * 2)
mark = marktools.LilyPondCommandMark('voiceOne')(vA[0])
mark = marktools.LilyPondCommandMark('voiceOne')(vB[0])
mark = marktools.LilyPondCommandMark('voiceTwo')(vC[0])
p = Container([vB, vC])
p.is_parallel = True
staff = Staff([vA, p])
</abjad>

<abjad>
f(staff)
</abjad>

<abjad>
show(staff, docs=True)
</abjad>

There's a staff that sequentially contains a voice and a parallel container.
The container in turn holds two voices running simultaneously.

It is now clear from the code that the last *A* belongs with the two descending eighth notes.
But there's still no indication about a relationship of continuity between the first voice
in the sequence (`vA`) and any of the two following voices.
Note that, while the LilyPond voice number commands setting may suggest
that vA and vB belong together, this is not the case.
The LilyPond voice number commands simply set the direction of stems in printed output.

To see this more clearly, suppose we want to add a slur spanner starting on the
first note and ending on one of the last simultaneous notes.
To attach the slur spanner to the voices we could try either:

<abjad>
spannertools.SlurSpanner([vA, vB])
</abjad>

... or ...

<abjad>
spannertools.SlurSpanner([vA, vC])
</abjad>

But both raise a contiguity error.
Abjad needs to see an explicit connection between either `vA` and `vB` or between `vA` and `vC`.

Observe the behavior of the
:func:`~abjad.tools.iterationtools.iterate_thread_in_expr`
iterator on the `staff`:

<abjad>
vA_thread_signature = vA.parentage.containment_signature
notes = iterationtools.iterate_thread_in_expr(staff, Note, vA_thread_signature)
print list(notes)
</abjad>

<abjad>
vB_thread_signature = vB.parentage.containment_signature
notes = iterationtools.iterate_thread_in_expr(staff, Note, vB_thread_signature)
print list(notes)
</abjad>

<abjad>
vC_thread_signature = vC.parentage.containment_signature
notes = iterationtools.iterate_thread_in_expr(staff, Note, vC_thread_signature)
print list(notes)
</abjad>

In each case we are passing a different **thread signature** to the
:func:`~abjad.tools.iterationtools.iterate_thread_in_expr`
iterator, so each case returns a different list of notes.

We can see that the thread signature of each voice is indeed different
by printing it:

<abjad>
vA_thread_signature = vA.parentage.containment_signature
vA_thread_signature
</abjad>

<abjad>
vB_thread_signature = vB.parentage.containment_signature
vB_thread_signature
</abjad>

<abjad>
vC_thread_signature = vC.parentage.containment_signature
vC_thread_signature
</abjad>

And by comparing them with the binary equality operator:

<abjad>
vA_thread_signature == vB_thread_signature
vA_thread_signature == vC_thread_signature
vB_thread_signature == vC_thread_signature
</abjad>

To allow Abjad to treat the content of, say, voices `vA` and `vB` as belonging together,
we explicitly define a thread between them.
To do this  all we need to do is give both voices the same name:

<abjad>
vA.name = 'piccolo'
vB.name = 'piccolo'
</abjad>

Now `vA` and `vB` and all their content belong to the same thread:

<abjad>
vA_thread_signature == vB_thread_signature
</abjad>

Note how the thread signatures have changed:

<abjad>
vA_thread_signature = vA.parentage.containment_signature
print vA_thread_signature
</abjad>

<abjad>
vB_thread_signature = vB.parentage.containment_signature
print vB_thread_signature
</abjad>

<abjad>
vC_thread_signature = vC.parentage.containment_signature
print vC_thread_signature
</abjad>

And how the ``iterationtools.iterate_thread_in_expr()`` function returns
all the notes belonging to both `vA` and `vB` when passing it the full staff
and the thread signature of `vA`:

<abjad>
notes = iterationtools.iterate_thread_in_expr(staff, Note, vA_thread_signature)
print list(notes)
</abjad>

Now the slur spanner can be applied to voices `vA` and `vB`:

<abjad>
spannertools.SlurSpanner([vA, vB])
</abjad>

or directly to the notes returned by the
:func:`~abjad.tools.iterationtools.iterate_thread_in_expr`
iteration tool, which are the notes belonging to both `vA` and `vB`:

<abjad>
notes = iterationtools.iterate_thread_in_expr(staff, Note, vA_thread_signature)
spannertools.SlurSpanner(list(notes))
</abjad>

<abjad>
show(staff, docs=True)
</abjad>

Coda
----

We could have constructed this score in a simpler way with only two voices,
one of them starting with a LilyPond skip:

<abjad>
vX = Voice(notetools.make_notes([5, 7, 9, 11, 12, 11, 9], [(1, 8)] * 6 + [(1, 4)]))
vY = Voice([skiptools.Skip((2, 4))] + Note(12, (1, 4)) * 2)
mark = marktools.LilyPondCommandMark('voiceOne')(vX[0])
mark = marktools.LilyPondCommandMark('voiceTwo')(vY[0])
staff = Staff([vX, vY])
staff.is_parallel = True
</abjad>

<abjad>
f(staff)
</abjad>

<abjad>
show(staff, docs=True)
</abjad>
