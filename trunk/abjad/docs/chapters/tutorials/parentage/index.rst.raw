Working with component parentage
================================

Many score objects contain other score objects.

<abjad>
tuplet = Tuplet(Fraction(2, 3), "c'4 d'4 e'4")
staff = Staff(2 * tuplet)
score = Score([staff])
show(score)
iotools.write_expr_to_ly(score, 'parentage-tutorial-1', 'oedo') <hide
</abjad>

Abjad uses the idea of parentage to model the way objects contain each other.

Improper parentage
------------------

The improper parentage of the first note in score begins with the note itself:

<abjad>
note = score.leaves[0]
print repr(note) <hide
</abjad>

<abjad>
componenttools.get_improper_parentage_of_component(note)
print repr(componenttools.get_improper_parentage_of_component(note)) <hide
</abjad>

Proper parentage
----------------

The proper parentage of the note begins with only the immediate parent of the note:

<abjad>
componenttools.get_proper_parentage_of_component(note)
print repr(componenttools.get_proper_parentage_of_component(note)) <hide
</abjad>

.. note:: the length of the improper parentage of any component equals
    the length of the proper parentage of the component plus ``1``.

Parentage attributes
--------------------

Use component tools to find score depth:

<abjad>
componenttools.component_to_score_depth(note)
print repr(componenttools.component_to_score_depth(note)) <hide>
</abjad>

Or score root:

<abjad>
componenttools.component_to_score_root(note)
print repr(componenttools.component_to_score_root(note)) <hide>
</abjad>

Or to find whether a component has no (proper) parentage at all:

<abjad>
componenttools.is_orphan_component(note)
print repr(componenttools.is_orphan_component(note)) <hide>
</abjad>
