Threads
=======


What is a thread?
-----------------

Abjad has the notion of a :term:`thread`. A thread is a structural relationship binding a set of strictly sequential :class:`~abjad.Voice.voice.Voice` level Abjad component, such as notes, rests, chords, tuplets or plain containers.

Threads may be *explicitly* defined via :class:`~abjad.Voice.voice.Voice` instances: 

<abjad>
v = Voice( )
</abjad>

or they may exist *implicitly* in certain score constructs in the absence of :class:`~abjad.Voice.voice.Voice` containers:

<abjad>
staff = Staff(macros.scale(4))
</abjad>

The existence of :class:`~abjad.Voice.voice.Voice` objects does not, however, guarantee the existence of a thread between the element contained in different voices. Two contiguous voices *must* have the same name in order to be part of the same thread. 

Here a thread does *not* exist between notes in the different :class:`~abjad.Voice.voice.Voice` contexts:

<abjad>
v_one = Voice(macros.scale(4, (1, 16)))
v_two = Voice(macros.scale(2))
staff = Staff([v_one, v_two])
f(staff)
</abjad>


Here a thread does exist:

<abjad>
v_one.name = 'flute'
v_two.name = 'flute'
f(staff)
</abjad>



What are threads for?
---------------------

Consider the following situation:

.. image:: images/thread-resolution_1.png


Are the two eighth notes in the second half of the measure the continuation of the ascending line in the first half, or is it the quarter note? 
Is the very last *C* the continuation of the top melodic line or is it the *A*?  
The stems might suggest an answer, but for Abjad, stem direction is not structural.  
What path should Abjad take to traverse this little score from the first note to the last *A*? This same problem appears when trying to apply spanners to parallel structures.  Thus, threads are important in both score navigation (also called score traversal) and :class:`~abjad.spanner.spanner.Spanner` application.
In fact, threads are a *requirement* for :class:`~abjad.spanner.spanner.Spanner` application. 

In Abjad, the ambiguity is resolved through the explicit use of named Voices, i.e. the explicit definition of threads. 

The above musical fragment is constructed with the following code:

<abjad>
vA = Voice(leaftools.make_notes([5, 7, 9, 11], [(1, 8)] * 4))
vB = Voice(leaftools.make_notes([12, 11, 9], [(1, 8), (1, 8), (1, 4)]))
vC = Voice(Note(12, (1, 4)) * 2)
vA.voice.number = 1
vB.voice.number = 1
vC.voice.number = 2
p = Container([vB, vC])
p.parallel = True
staff = Staff([vA, p])
write_ly(staff, 'thread-resolution_1', 'oedo') <hide
</abjad>

There's a :class:`~abjad.Staff.staff.Staff` that sequentially contains a :class:`~abjad.Voice.voice.Voice` and a parallel :class:`~abjad.Container.container.Container`. The :class:`~abjad.Container.container.Container` in turn holds two Voices running simultaneously. 

It is now clear from the code that the last *A* belongs with the two descending eighth notes. But there's still no indication about a relationship of continuity between the first :class:`~abjad.Voice.voice.Voice` in the sequence (`vA`) and any of the two following Voices. 
Note that, while the voice number setting (``vA.voice.number = 1``) may suggest that vA and vB belong together, this is not the case. The ``voice.number`` attribute simply sets the direction of the stems in the final printed output. 

To see this more clearly, suppose we want to add a :class:`~abjad.slur.spanner.Slur` starting on the first :class:`~abjad.Note.note.Note` and ending on one of the last simultaneous Notes. To attach the :class:`~abjad.slur.slur.Slur` spanner to Voices we could either try: 

::

   abjad> Slur([vA, vB])

or

::

   abjad> Slur([vA, vC])

but both throw a :class:`~abjad.exceptions.exceptions.ContiguityError`. *Abjad* needs to see an explicit connection between either `vA` and `vB` or `vA` and `vC`. 

Observe the behavior of the :func:`~abjad.tools.iterate.thread.thread` iterator on the `staff`.

<abjad>
notes = iterate.thread(staff, Note, vA.thread.signature)
print list(notes)
</abjad>

<abjad>
notes = iterate.thread(staff, Note, vB.thread.signature)
print list(notes)
</abjad>

<abjad>
notes = iterate.thread(staff, Note, vC.thread.signature)
print list(notes)
</abjad>

In each case we are passing a different *thread signature* to the :func:`~abjad.tools.iterate.thread.thread` iterator, so each case returns a different list of Notes.

.. note::
   All *Abjad* Components have a :class:`~abjad.thread.interface.ThreadInterface`.


We can see that the *thread signature* of each voice is indeed different by calling the ``report( )`` method on each of the Voice's :class:`~abjad.thread.interface.ThreadInterface`.

<abjad>
vA.thread.report( )
</abjad>

<abjad>
vB.thread.report( )
</abjad>

<abjad>
vC.thread.report( )
</abjad>

And by comparing them with the ``==`` binary operator:

<abjad>
print vA.thread.signature == vB.thread.signature
print vA.thread.signature == vC.thread.signature
print vB.thread.signature == vC.thread.signature
</abjad>

To allow *Abjad* to treat the content of, say, voices `vA` and `vB` as belonging together, we explicitly define a thread between them. To do this  all we need to do is name these Voices equally:

<abjad>
vA.name = 'piccolo'
vB.name = 'piccolo'
</abjad>

Now `vA` and `vB` and all their content belong to the same thread.

<abjad>
print vA.thread.signature == vB.thread.signature
</abjad>

Note how the *thread signatures* have changed:

<abjad>
vA.thread.report( )
</abjad>

<abjad>
vB.thread.report( )
</abjad>

<abjad>
vC.thread.report( )
</abjad>


And how the ``iterate.thread( )`` function returns all the Notes belonging to both `vA` and `vB` when passing it the full `staff` and the *thread signature* of `vA`.

<abjad>
notes = iterate.thread(staff, Note, vA.thread.signature)
print list(notes)
</abjad>

Now the :class:`~abjad.slur.spanner.Slur` spanner can be applied to Voices `vA` and `vB`:

::

   abjad> Slur([vA, vB])

or directly to the Notes returned by the :func:`~abjad.tools.iterate.thread.thread` iteration tool, which are the Notes belonging to both `vA` and `vB`:

<abjad>
notes = iterate.thread(staff, Note, vA.thread.signature)
Slur(list(notes))
</abjad>

<abjad>
show(staff)
write_ly(staff, 'thread-resolution_2', 'oedo') <hide
</abjad>


Coda
^^^^

Incidentally, we could have constructed this score in a simpler way with only two Voices, one of them starting with a :class:`~abjad.Skip.skip.Skip`:

.. note:: 
   A :class:`~abjad.Skip.skip.Skip` is like an invisible :class:`~abjad.Rest.rest.Rest`.


<abjad>
vX = Voice(leaftools.make_notes([5, 7, 9, 11, 12, 11, 9], [(1, 8)] * 6 + [(1, 4)]))
vY = Voice([Skip((2, 4))] + Note(12, (1, 4)) * 2)
vX.voice.number = 1
vY.voice.number = 2
staff = Staff([vX, vY])
staff.parallel = True
write_ly(staff, 'thread-resolution_3', 'oedo') <hide
</abjad>


But that would have defeated the purpose of this section!

