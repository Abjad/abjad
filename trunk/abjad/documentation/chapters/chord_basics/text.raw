<h1>Working with chords</h1>

<subsection>Chord initialization
<p>Initialize <Chord> with a list of <Pitch> instances and a <Rational>.</p>
<abjad>
   abjad> chord = Chord([Pitch(2), Pitch(4), Pitch(5)], Rational(1, 4))
   hide> measure = Measure(chord.duration.prolated.pair, [chord])
   hide> measure.meter.transparent = True
   hide> show(measure)
</abjad>
<p>You can use a <notehead token> list as shortcut for the first input parameter. And you can use a <duration token> as a shortcut for the second.</p>
</subsection>

<subsection>Duration attributes
<p><Chord> has a <_LeafDurationInterface>.</p>
<abjad>
   abjad> tuplet = FixedDurationTuplet((1, 4), Chord([2, 4, 5], (1, 8)) * 3)
   abjad> chord = tuplet[1]
   abjad> chord.duration
   &lt;_LeafDurationInterface&gt;
</abjad>
<p><_LeafDurationInterface> bundles six public attributes.</p>
<abjad>
   hide> tuplet = FixedDurationTuplet((1, 4), Chord([2, 4, 5], (1, 8)) * 3)
   hide> chord = tuplet[1]
   abjad> chord.duration.multiplied
   Rational(1, 8)
</abjad>
<abjad>
   hide> tuplet = FixedDurationTuplet((1, 4), Chord([2, 4, 5], (1, 8)) * 3)
   hide> chord = tuplet[1]
   abjad> chord.duration.multiplier
   Rational(1, 1)
</abjad>
<abjad>
   hide> tuplet = FixedDurationTuplet((1, 4), Chord([2, 4, 5], (1, 8)) * 3)
   hide> chord = tuplet[1]
   abjad> chord.duration.preprolated
   Rational(1, 8)
</abjad>
<abjad>
   hide> tuplet = FixedDurationTuplet((1, 4), Chord([2, 4, 5], (1, 8)) * 3)
   hide> chord = tuplet[1]
   abjad> chord.duration.prolated
   Rational(1, 12)
</abjad>
<abjad>
   hide> tuplet = FixedDurationTuplet((1, 4), Chord([2, 4, 5], (1, 8)) * 3)
   hide> chord = tuplet[1]
   abjad> chord.duration.prolation
   Rational(2, 3)
</abjad>
<abjad>
   hide> tuplet = FixedDurationTuplet((1, 4), Chord([2, 4, 5], (1, 8)) * 3)
   hide> chord = tuplet[1]
   abjad> chord.duration.written
   Rational(1, 8)
</abjad>
<p>Read more at <_LeafDurationInterface>.</p>
</subsection>

<subsection>Duration attribute assignment
<p>You can reassign <tt>chord.duration.written</tt>.</p>
<abjad>
   abjad> chord = Chord([2, 4, 5], (1, 4))
</abjad>
<abjad>
   hide> chord = Chord([2, 4, 5], (1, 4))
   abjad> chord.duration.written = Rational(3, 16)
   hide> measure = Measure(chord.duration.prolated.pair, [chord])
   hide> measure.meter.transparent = True
   hide> show(measure)
</abjad>
<p>You must use a <Rational> which meets <assignability> criteria.</p>
<p>You can also assign <tt>chord.duration.multiplier</tt>.</p>
<abjad>
   abjad> chord = Chord([2, 4, 5], (1, 4))
   abjad> chord.duration.multiplier = Rational(1, 6)
</abjad>
<abjad>
   hide> chord = Chord([2, 4, 5], (1, 4))
   hide> chord.duration.mutiplier = Rational(1, 6)
   abjad> chord.duration.written
   Rational(1, 4)
   abjad> chord.duration.multiplier
   Rational(1, 6)
   abjad> chord.duration.multiplied
   Rational(1, 24)
</abjad>
<p>Use any positive <Rational>.</p>
<p>All other duration attributes are read-only.</p>
</subsection>

<subsection>Chord length
<p><Chord> implements <code>len( )</code> as the number of noteheads in <code>self</code>.</p>
<abjad>
   abjad> chord = Chord([2, 4, 5], (1, 4))
   abjad> len(chord)
   3
</abjad>
</subsection>

<subsection>Adding noteheads
<p><Chord> implements bound <code>append( )</code> and <code>extend( )</code> methods to mimic the built-in Python list.</p>
<p>Use <code>append( )</code> to add one notehead.</p>
<abjad>
   abjad> chord = Chord([2, 4, 5], (1, 4))
   abjad> chord.append(10)
   hide> measure = Measure(chord.duration.written.pair, [chord])
   hide> measure.meter.transparent = True
   hide> show(measure)
</abjad>
<p>Use <code>extend( )</code> to add a list of noteheads.</p>
<abjad>
   abjad> chord = Chord([2, 4, 5], (1, 4))
   abjad> chord.extend([10, 12])
   hide> measure = Measure(chord.duration.written.pair, [chord])
   hide> measure.meter.transparent = True
   hide> show(measure)
</abjad>
<p>Any <notehead token> will do.</p>
<p>TODO: why isn't <_NoteHead> public? Shouldn't it be possible to instantiate a <_NoteHead> by hand and then assign to a chord with <code>append</code> or <code>extend</code>? This would mean extending <code>append</code> and <code>extend</code> somewhat but would increase composer interface consistency.</p>
</subsection>

<subsection>Removing noteheads
<p><Chord> implements <code>remove( )</code> and <code>pop( )</code> methods to mirror the interface of the built-in Python list.</p>
<p>The <code>remove( )</code> method works by notehead reference.</p>
<abjad>
   abjad> chord = Chord([2, 4, 5], (1, 4))
   abjad> chord.remove(chord[0])
   hide> measure = Measure(chord.duration.written.pair, [chord])
   hide> measure.meter.transparent = True
   hide> show(measure)
</abjad>
<p>The <code>pop( )</code> method works by zero-indexed integer. Negative indices are allowed.</p>
<abjad>
   abjad> chord = Chord([2, 4, 5], (1, 4))
   abjad> chord.pop(-1)
   hide> measure = Measure(chord.duration.written.pair, [chord])
   hide> measure.meter.transparent = True
   hide> show(measure)
</abjad>
<p>Note that <code>pop( )</code> defaults to <code>-1</code>.</p>
</subsection>

<subsection>Listing noteheads
<p><Chord> gives all noteheads as a list.</p>
<abjad>
   abjad> chord = Chord([2, 4, 5], (1, 4))
   abjad> chord.notheads
   [_NoteHead(d'), _NoteHead(e'), _NoteHead(f')]
</abjad>
<p>It is always the case that <code>len(chord) == len(chord.noteheads)</code>.</p>
<p>Note that <code>chord.noteheads.remove(chord[0])</code>, for example, does nothing because <Chord> generates <code>noteheads</code> as a newly instantiated list on each request. Use <code>chord.remove(chord[0])</code> instead.</p>
</subsection>

<subsection>Listing pitches
<p><Chord> gives all pitches as a list.</p>
<abjad>
   abjad> chord = Chord([2, 4, 5], (1, 4))
   abjad> chord.pitches
   [Pitch(d, 4), Pitch(e, 4), Pitch(f, 4)]
</abjad>
<p>It is always the case that <code>len(chord) == len(chord.pitches)</code>.</p>
<p>Note that <code>chord.pitches.remove(chord[0].pitch)</code>, for example, does nothing. Use <code>chord.remove(chord[0])</code> instead.</p>
</subsection>

<subsection>Grob handling
<p><Chord> is not a LilyPond grob handler because there is no LilyPond chord grob. This means that assignments such as, for example, <code>chord.color = 'red'</code> carry no special meaning in Abjad.</p>
<p>Note, however, that, because there is a LilyPond notehead grob, the Abjad <_NoteHead> does act as a grob handler.</p>
<abjad>
   abjad> chord = Chord([2, 4, 5], (1, 4))
   abjad> notehead = chord[0]
   abjad> notehead.color = 'red'
   abjad> f(chord)
   &lt;
      \tweak #'color #red
      d'
      e'
      f'
   &gt;4
</abjad>
<p>This is a handy feature that shows a uniform Abjad syntax neatly covering an usual bit of LilyPond syntax.</p>
</subsection>

<subsection>Chord comparison
<p>When are two chords 'equal'? When are two chords 'the same'? We could argue that two chords are equal when they exhibit the same pitch content. Alternatively, we could insistent on durational equivalence. Or on pitch and durational equivalence. And what about articulations, beams and flags, dynamics, glissandi, slurs and other connectors? Or stem direction? Abjad makes it very easy to compare all of these attributes and more. But it seems unwise to elevate any one or two of these potential types of attribute comparison to the position of canonic chord comparison. For this reason, Abjad admits a large number of chord attribute comparison tests but no chord comparison test proper.</p>

<p>Actually, Abjad does not block the built-in Python <code>cmp( )</code> function on chords. This means that statements like <code>chord1 == chord2</code> will evaluate to either true or false. More specifically, two chords will compare as true if and only if the chords share a single reference in the interpreter, ie, <code>id(chord1) == id(chord2)</code>. This type of comparison is fundamentally nonsemantic and, in fact, begs the question of whether <Chord> and, indeed, all Abjad components should block Python comparison explicitly. This seems to be especially the case when we consider that expressions like <code>chord1 > chord2</code> and <code>chord1 &lt; chord2</code> do unfortunately evaluate in the current implementation. The value of greater-than / less-than comparison on <Chord> is highly conterintuitive and should qualify as a problem in the model.</p>

<p> TODO: these changes are DONE in the current commit. <_Component> now blocks Python comparison explicitly with the important exception of <code>__eq__</code> and <code>__ne__</code> which are now implemented as ID-comparison only. This allows, for example, <code>chord1 == chord2</code> for <code>list.index( )</code> to work while blocking <code>chord1 > chord2</code> and <code>chord1 &lt; chord2</code> explicitly. Leave for a couple of days and then adjust this part of the docs in the preceding paragraph to reflect these changes.</p>
</subsection>

<comments>

<p>Abjad allows the instantiation of empty chords with <code>Chord([ ], (1, 4))</code> and the like. Consider this an undocumented behavior that may deprecate in future.</p>

</comments>
