<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<link rel="stylesheet" href="../../css/abjad.css" type="text/css"/>

<title>The Abjad Doc Site</title>

</head>

<body>

<div id="content">

<h1>Working with chords</h1>

<div class="subsection">

<h2>Chord initialization</h2>
<p> Initialize <code><a href="../chord_class/index.html">Chord</a></code> with a list of <code><a href="../pitch_class/index.html">Pitch</a></code> instances and a <code><a href="../rational_class/index.html">Rational</a></code>.
<pre class="abjad">
abjad> chord = Chord([Pitch(2), Pitch(4), Pitch(5)], Rational(1, 4))
</pre>
<img src="images/1.png">
<p> You can use a <code><a href="../notehead_token/index.html">notehead token</a></code> list as shortcut for the first input parameter. And you can use a <code><a href="../duration_token/index.html">duration token</a></code> as a shortcut for the second.
</div>

<div class="subsection">

<h2>Duration attributes</h2>
<p> <code><a href="../chord_class/index.html">Chord</a></code> has a <code><a href="../leaf_duration_interface_class/index.html">_LeafDurationInterface</a></code>.
<pre class="abjad">
abjad> tuplet = FixedDurationTuplet((1, 4), Chord([2, 4, 5], (1, 8)) * 3)
abjad> chord = tuplet[1]
abjad> chord.duration
&lt;_LeafDurationInterface&gt;
</pre>
<p> <code><a href="../leaf_duration_interface_class/index.html">_LeafDurationInterface</a></code> bundles six public attributes.
<pre class="abjad">
abjad> chord.duration.multiplied
Rational(1, 8)
</pre>
<pre class="abjad">
abjad> chord.duration.multiplier
Rational(1, 1)
</pre>
<pre class="abjad">
abjad> chord.duration.preprolated
Rational(1, 8)
</pre>
<pre class="abjad">
abjad> chord.duration.prolated
Rational(1, 12)
</pre>
<pre class="abjad">
abjad> chord.duration.prolation
Rational(2, 3)
</pre>
<pre class="abjad">
abjad> chord.duration.written
Rational(1, 8)
</pre>
<p> Read more at <code><a href="../leaf_duration_interface_class/index.html">_LeafDurationInterface</a></code>.
</div>

<div class="subsection">

<h2>Duration attribute assignment</h2>
<p> You can reassign <tt>chord.duration.written</tt>.
<pre class="abjad">
abjad> chord = Chord([2, 4, 5], (1, 4))
</pre>
<pre class="abjad">
abjad> chord.duration.written = Rational(3, 16)
</pre>
<img src="images/2.png">
<p> You must use a <code><a href="../rational_class/index.html">Rational</a></code> which meets <code><a href="../assignability/index.html">assignability</a></code> criteria.
<p> You can also assign <tt>chord.duration.multiplier</tt>.
<pre class="abjad">
abjad> chord = Chord([2, 4, 5], (1, 4))
abjad> chord.duration.multiplier = Rational(1, 6)
</pre>
<pre class="abjad">
abjad> chord.duration.written
Rational(1, 4)
abjad> chord.duration.multiplier
Rational(1, 6)
abjad> chord.duration.multiplied
Rational(1, 24)
</pre>
<p> Use any positive <code><a href="../rational_class/index.html">Rational</a></code>.
<p> All other duration attributes are read-only.
</div>

<div class="subsection">

<h2>Chord length</h2>
<p> <code><a href="../chord_class/index.html">Chord</a></code> implements <code>len( )</code> as the number of noteheads in <code>self</code>.
<pre class="abjad">
abjad> chord = Chord([2, 4, 5], (1, 4))
abjad> len(chord)
3
</pre>
</div>

<div class="subsection">

<h2>Adding noteheads</h2>
<p> <code><a href="../chord_class/index.html">Chord</a></code> implements bound <code>append( )</code> and <code>extend( )</code> methods to mimic the built-in Python list.
<p> Use <code>append( )</code> to add one notehead.
<pre class="abjad">
abjad> chord = Chord([2, 4, 5], (1, 4))
abjad> chord.append(10)
</pre>
<img src="images/3.png">
<p> Use <code>extend( )</code> to add a list of noteheads.
<pre class="abjad">
abjad> chord = Chord([2, 4, 5], (1, 4))
abjad> chord.extend([10, 12])
</pre>
<img src="images/4.png">
<p> Any <code><a href="../notehead_token/index.html">notehead token</a></code> will do.
<p> TODO: why isn't <code><a href="../notehead_class/index.html">_NoteHead</a></code> public? Shouldn't it be possible to instantiate a <code><a href="../notehead_class/index.html">_NoteHead</a></code> by hand and then assign to a chord with <code>append</code> or <code>extend</code>? This would mean extending <code>append</code> and <code>extend</code> somewhat but would increase composer interface consistency.
</div>

<div class="subsection">

<h2>Removing noteheads</h2>
<p> <code><a href="../chord_class/index.html">Chord</a></code> implements <code>remove( )</code> and <code>pop( )</code> methods to mirror the interface of the built-in Python list.
<p> The <code>remove( )</code> method works by notehead reference.
<pre class="abjad">
abjad> chord = Chord([2, 4, 5], (1, 4))
abjad> chord.remove(chord[0])
</pre>
<img src="images/5.png">
<p> The <code>pop( )</code> method works by zero-indexed integer. Negative indices are allowed.
<pre class="abjad">
abjad> chord = Chord([2, 4, 5], (1, 4))
abjad> chord.pop(-1)
</pre>
<img src="images/6.png">
<p> Note that <code>pop( )</code> defaults to <code>-1</code>.
</div>

<div class="subsection">

<h2>Listing noteheads</h2>
<p> <code><a href="../chord_class/index.html">Chord</a></code> gives all noteheads as a list.
<pre class="abjad">
abjad> chord = Chord([2, 4, 5], (1, 4))
abjad> chord.notheads
[_NoteHead(d'), _NoteHead(e'), _NoteHead(f')]
</pre>
<p> It is always the case that <code>len(chord) == len(chord.noteheads)</code>.
<p> Note that <code>chord.noteheads.remove(chord[0])</code>, for example, does nothing because <code><a href="../chord_class/index.html">Chord</a></code> generates <code>noteheads</code> as a newly instantiated list on each request. Use <code>chord.remove(chord[0])</code> instead.
</div>

<div class="subsection">

<h2>Listing pitches</h2>
<p> <code><a href="../chord_class/index.html">Chord</a></code> gives all pitches as a list.
<pre class="abjad">
abjad> chord = Chord([2, 4, 5], (1, 4))
abjad> chord.pitches
[Pitch(d, 4), Pitch(e, 4), Pitch(f, 4)]
</pre>
<p> It is always the case that <code>len(chord) == len(chord.pitches)</code>.
<p> Note that <code>chord.pitches.remove(chord[0].pitch)</code>, for example, does nothing. Use <code>chord.remove(chord[0])</code> instead.
</div>

<div class="subsection">

<h2>Grob handling</h2>
<p> <code><a href="../chord_class/index.html">Chord</a></code> is not a LilyPond grob handler because there is no LilyPond chord grob. This means that assignments such as, for example, <code>chord.color = 'red'</code> carry no special meaning in Abjad.
<p> Note, however, that, because there is a LilyPond notehead grob, the Abjad <code><a href="../notehead_class/index.html">_NoteHead</a></code> does act as a grob handler.
<pre class="abjad">
abjad> chord = Chord([2, 4, 5], (1, 4))
abjad> notehead = chord[0]
abjad> notehead.color = 'red'
abjad> f(chord)
<
\tweak #'color #red
d'
e'
f'
>4
</pre>
<p> This is a handy feature that shows a uniform Abjad syntax neatly covering an usual bit of LilyPond syntax.
</div>

<div class="subsection">

<h2>Chord comparison</h2>
<p> When are two chords 'equal'? When are two chords 'the same'? We could argue that two chords are equal when they exhibit the same pitch content. Alternatively, we could insistent on durational equivalence. Or on pitch and durational equivalence. And what about articulations, beams and flags, dynamics, glissandi, slurs and other connectors? Or stem direction? Abjad makes it very easy to compare all of these attributes and more. But it seems unwise to elevate any one or two of these potential types of attribute comparison to the position of canonic chord comparison. For this reason, Abjad admits a large number of chord attribute comparison tests but no chord comparison test proper.
<p> Actually, Abjad does not block the built-in Python <code>cmp( )</code> function on chords. This means that statements like <code>chord1 == chord2</code> will evaluate to either true or false. More specifically, two chords will compare as true if and only if the chords share a single reference in the interpreter, ie, <code>id(chord1) == id(chord2)</code>. This type of comparison is fundamentally nonsemantic and, in fact, begs the question of whether <code><a href="../chord_class/index.html">Chord</a></code> and, indeed, all Abjad components should block Python comparison explicitly. This seems to be especially the case when we consider that expressions like <code>chord1 > chord2</code> and <code>chord1 < chord2</code> do unfortunately evaluate in the current implementation. The value of greater-than / less-than comparison on <code><a href="../chord_class/index.html">Chord</a></code> is highly conterintuitive and should qualify as a problem in the model.
<p> TODO: these changes are DONE in the current commit. <code><a href="../component_class/index.html">_Component</a></code> now blocks Python comparison explicitly with the important exception of <code>__eq__</code> and <code>__ne__</code> which are now implemented as ID-comparison only. This allows, for example, <code>chord1 == chord2</code> for <code>list.index( )</code> to work while blocking <code>chord1 > chord2</code> and <code>chord1 < chord2</code> explicitly. Leave for a couple of days and then adjust this part of the docs in the preceding paragraph to reflect these changes.
</div>

<h2 class="page-section">Comments</h2>

<div class="comments">

<p> Abjad allows the instantiation of empty chords with <code>Chord([ ], (1, 4))</code> and the like. Consider this an undocumented behavior that may deprecate in future.

</div>

<p class="footer"><a href="../../index.html">Contents</a></p>

</div>

</body>

</html>

