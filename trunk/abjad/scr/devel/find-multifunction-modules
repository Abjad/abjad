#! /usr/bin/env python

from abjad import ABJCFG
from abjad.tools import iotools
import os
import pprint
import re


class_definition_pattern = re.compile(r'\s*class\s+(\w+)')
function_definition_pattern = re.compile(r'\s*def\s+(\w+)')

def _find_multifunction_modules():
   multifunction_modules = [ ]
   tools_directory = os.path.join(ABJCFG.ABJAD_PATH, 'tools')
   for path, subdirectories, files in os.walk(tools_directory):
      for f in files:
         if f.endswith('.py'):
            if not f.startswith('test_'):
               result = _has_multiple_public_function_definitions(path, f)
               if result:
                  result_pair = (f, result)
                  multifunction_modules.append(result_pair)
   total = len(multifunction_modules)
   if 0 < total:
      pprint.pprint(multifunction_modules)
      print ''
   print 'Total modules with multiple public functions defined: %s' % total
   print ''


def _has_multiple_public_function_definitions(path, f):
   function_names = [ ]
   full_name = os.path.join(path, f)
   for line in file(full_name, 'r').readlines():
      match = class_definition_pattern.match(line)
      if match is not None:
         return False
      match = function_definition_pattern.match(line)
      if match is not None:
         function_name = match.groups()[0]
         if not function_name.startswith('_'):
            function_names.append(function_name)
   if 1 < len(function_names):
      return function_names
   else:
      return False


if __name__ == '__main__':
   iotools.clear_terminal()
   _find_multifunction_modules()
