1.  Afford rhythm setting lookup of parseable string. This will make ...
        red_segment.set_rhythm("c'32 [ c'16 c'16. ]", contexts=['Voice 1'])
        voice_1_rhythm_command = red_segment.timespan.start_offset.look_up_rhythm_setting('Voice 1')
        red_segment.set_rhythm(voice_1_rhythm_command, contexts=['Voice 2'])
    ... interpret correctly.
    Then make X5 work with rhythm setting lookup instead of rhythm selector.

2.  Notice that the SegmentSpecification.set_divisions() 'truncate' keyword means two things.
    It means truncate last division in section. It also means restart divisions at
    beginning of following section. Implement a SegmentSpecification.set_divisions()
    boolean 'restart' keyword to separate these functions. When restart=True
    then truncate will always effectively be interpreted as true.

3.  Can start_segment_identifier properties eventually be completely removed from model?
    What should be possible is for code to look at any timespan expression and get start segment specification.
    There is in fact an Interpreter.get_start_segment_specification() method right now.
    How does this relate to the "reanchoring" of settings during interpretation?

4.  Rename _set_start_segment_identifier().
    Maybe should be called _set_anchor(). Not sure.
    In fact it's possible that the entire notion of "start segment identifier" reduces to "anchor".
    If that turns out to be the case then "start segment specification" is
    something like "anchor segment specification".
    And more generally we have "anchor specification" to allow both score- and segment-anchoring.

5.  Implement some sort of "cake slice" management interface on SegmentSpecification and ScoreSpecification.
    Currently we must use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        rhythm = red_segment.select_leaves('Voice 1', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 1'])
        rhythm = red_segment.select_leaves('Voice 2', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 2'])
        rhythm = red_segment.select_leaves('Voice 3', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 3'])
        rhythm = red_segment.select_leaves('Voice 4', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 4'])
    ... when it might be possible to use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        selected_voices = ['Voice 1', 'Voice 2', 'Voice 3', 'Voice 4']
        rhythm = red_segment.select_leaves(selected_voices, timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=selected_voices)
    ... instead.
    This will simplify the X9 composer interface.

6.  Unskip all experimental tests before 2.11 build.

7.  Finish timerelationtools class docstrings before 2.11 build.

8.  Finish timespantools package docstrings before 2.11 build.

9.  Add examples to the docstrings of all experimental class methods and properties before 2.11 build.

10. Author tests to make sure that persistent overlapping division selectors 
    can be overwritten in a subsequent segment.
    See test_multiple_segment_solo__persistent_overlapping_division_selectors_05().

11. Looks like callback stacks may not be copied over from segment to segment for persistent settings.
    Fix test_multiple_segment_solo__persistent_overlapping_division_selectors_03() to debug.

12. Extend OffsetExpression with an 'offset_callbacks' stack.
    Modifier methods include OffsetExpression.translate() and possibly others.

13. Audit all selector classes.
    Make sure each implements a self._get_timespan_and_payload() method.
    Make sure each also implement self._get_timesapn(), self._get_payload() methods.

14. Clean up region product docstrings.

15. Extend SelectMethodMixin with select_time_signatures() method.
    (Fine for the method to return BackgroundMeasureSelector.)
    (Fine to implement new TimeSignatureSelector that subclasses BackgroundMeasureSelector.)
    Then change ...
        measures = red_segment.select_background_measures('Voice 1')
        blue_segment.set_time_signatures(measures)
    ... to ...
        time_signatures = red_segment.select_time_signatures('Voice 1')
        red_segment.set_time_signatures(time_signatures)
    ... throughout tests.

16. Change BackgroundMeasureSelector to MeasureSelector.
    Change SelectMethodMixin.select_background_measures to SelectoMethodMixin.select_measures().
    Remove 'background' globally from the codebase.

17. Add a test to show this:
        note_selector = red_segment.select_notes_and_chords('Voice 1')[10:11]
        offset = note_selector.stop_offset

18. Add some tests to show this:
        measures = red_segment.select_background_measures('Voice 1')
        measures = measures[10:20]
        measures = measures[2:4]
    This will show getitem composition.

19. Add some tests to show this:
        segments = score_specification.select_segments()['red':('blue'+1)]
        middle_part = segments.set_offset(start=(3, 4), stop=(-3, 4))
        score_specification.set_divisions([(1, 16)])
        middle_part.set_divisions([(3, 16)])
    This will show setting divisions for (potentially) more than one segment.

20. Add some tests to show this:
        segments = score_specification.select_segments()['red':('blue'+1)]
        middle_measures = segments.select_background_measures('Voice 1')[3:6]
    This will show selecting background measures from (potentially) more than one segment.

21. Add some tests to show this:
        measures = red_segment.select_background_measures('Voice 1')[10:20]
        middle_third_of_measures = measures.partition_by_ratio((1, 1, 1))[1]
    This will show partitioning only part of a segment's measures.

22. Add some tests to show this:
        measures = red_segment.select_background_measures('Voice 1')
        middle_third_of_measures = measures.partition_by_ratio((1, 1, 1))[1]
        measure = middle_third_of_measures[:1]
    This will show slice selection following partition.

23. Add some tests to show this:
        first_half_of_red_segment = red_segment.timespan.divide_by_ratio((1, 1))[0]
        measures = first_half_of_red_segment.select_background_measures('Voice 1')
    This will show selecting background measures that start during a duration-partitioned part of segment.

24. Author tests to show each payload callback applied to each selector.
    Remaining tests to author:
        leaves.__getitem__()
        leaves.partition_by_ratio()
        leaves.partition_by_ratio_of_durations()
        leaves.repeat_to_duration()
        leaves.repeat_to_length()
        leaves.reflect()
        leaves.rotate()

25. Author payload callback tests for all payload callbacks on an AbsoluteExpression.

26. Implement _get_payload() on all RegionCommand classes.
    Do RegionCommand classes need _get_timespan() too?

27. Change primary usage pattern from ...
        score_template = scoretemplatetools.GroupedRhythmicStavesScoreTemplate(staff_count=1)
        score_specification = specificationtools.ScoreSpecification(score_template)
    ... to ...
        score_template = scoretemplatetools.GroupedRhythmicStavesScoreTemplate(staff_count=1)
        score_specification = settingtools.ScoreSpecificationInterface(score_template)
    ... so that composers are always only ever interacting with interfaces.

28. Add test to show this:
        setting = score_specification.get_offset(32, 5).look_up_rhythm_setting('Voice 1')

29. Implement Infinity and NegativeInfinity constants.
    Set Timespan start_offset=None to start_offset=NegativeInfinity.
    Set Timespan stop_offset=None to stop_offset=Infinity.

30. Disallow Timespan(start_offset, stop_offset) where stop_offset < start_offset.
    Check at initialization time.

31. Implement PayloadCallbackMixin.repeat_to_stop_offset() to work with CounttimeComponentSelector.
    Then write tests to make work with the other selectors, too.

32. Implement PayloadCallbackMixin.__and__() to work with CounttimeComponentSelector.
    Then write tests to make work with the other selectors, too.

33. Replace CounttimeComponentSelector._get_payload() custom code.
    Use PayloadCallbackMixing.__and__() and PayloadCallbackMixin.repeat_to_stop_offset() instead.

34. Streamline ConcreteInterpreter.make_rhythm_region_products().
    Change counttime_component_selector._get_payload(score_spec, voice_name, start_offset, stop_offset)
    to counttime_component_selector._get_payload(score_specification, voice_name).

35. Rename CounttimeComponentSelector to RhythmSelector.
    Rename SelectMethodMix.select_leaves() to SelectMethodMix.select_rhythm().

36. Move ClassInventory to settingtools.
