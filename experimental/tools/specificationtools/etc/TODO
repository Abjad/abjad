1. Remove 'series' from 'X series 7' and the like to produce just 'X 7'.
    Even better will be to extend helpertools.write_test_output() to write 'X7 'instead of 'X 7'.
    Also remove 'series' from test file name.

2.  Afford rhythm command request of parseable string. This will make ...
        red_segment.set_rhythm("c'32 [ c'16 c'16. ]", contexts=['Voice 1'])
        voice_1_rhythm_command = red_segment.start_offset.request_rhythm_command('Voice 1')
        red_segment.set_rhythm(voice_1_rhythm_command, contexts=['Voice 2'])
    ... interpret correctly.
    Then make X5 work with rhythm command request instead of rhythm request.

3.  Author tests to make sure that persistent overlapping division selectors 
    can be overwritten in a subsequent segment.
    See test_multiple_segment_solo__persistent_overlapping_division_selectors_05().

4.  Notice that the SegmentSpecification.set_divisions() 'truncate' keyword means two things.
    It means truncate last division in section. It also means restart divisions at
    beginning of following section. Implement a SegmentSpecification.set_divisions()
    boolean 'restart' keyword to separate these functions. When restart=True
    then truncate will always effectively be interpreted as true.

### ROTATION ###

5.  Extend OffsetPositionedRhythmExpression.rotate() with a new 'level=-1' keyword.
    The keyword will specify the score-tree level at which rotation should happen.
    The keyword will be an attribute of the RotationIndicator class.

6.  Reimplement rhythm rotation to pay attention to the differences beteween
    spanners that cover components and spanners that dominate components.
    Fill in missing spannertools docstrings before doing this.

7.  Extend RotationIndicator to allow for symoblic rotation by portion of total duration.
    Might look like rotation=settingtools.RotationIndicator((-1, 3)).
    Or like rotation=(-1, 3), rotation=(-2, 2), rotation(-3, 1).
    This also suggests a companion procedure that rotates based on ratio of total count of elements.

### MORE ###

8.  Finish timerelationtools class docstrings before 2.11 build.

9.  Author tests to show selecting leaves that don't yet exist.
    Make sure the command is ignored at first and then interpreted correctly in a later pass.

10. Audit to get rid of string-based keys everywhere in interpreter.

11. Add examples to the docstrings of all experimental class methods and properties before 2.11 build.

12. Unskip all experimental tests before 2.11 build.

13. Implement some sort of "cake slice" management interface on SegmentSpecification and ScoreSpecification.
    Currently we must use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        rhythm = red_segment.select_leaves('Voice 1', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 1'])
        rhythm = red_segment.select_leaves('Voice 2', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 2'])
        rhythm = red_segment.select_leaves('Voice 3', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 3'])
        rhythm = red_segment.select_leaves('Voice 4', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 4'])
    ... when it might be possible to use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        selected_voices = ['Voice 1', 'Voice 2', 'Voice 3', 'Voice 4']
        rhythm = red_segment.select_leaves(selected_voices, timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=selected_voices)
    ... instead.
    This will simplify the X9 composer interface.

14. Add some tests to show this:
        measures = red_segment.select_background_measures('Voice 1', 10, 20)
        measures = measures[2:4]
    This will show the composition of multiple slice selections in a row.

15. Add some tests to show this:
        segments = score_specification.select_segments('red', ('blue' + 1))
        middle_part = segments.set_offset(start=(3, 4), stop=(-3, 4))
        score_specification.set_divisions([(1, 16)])
        middle_part.set_divisions([(3, 16)])
    This will show anchoring to a segment selector that selects more than one segment.

16. Add some tests to show this:
        segments = score_specification.select_segments('red', ('blue' + 1))
        middle_measures = segments.select_background_measures('Voice 1', 3, 6)
    This will show selecting background measures from more than one segment.

17. Add some tests to show this:
        measures = red_segment.select_background_measures('Voice 1', 10, 20)
        middle_third_of_measures = measures.partition_objects_by_ratio((1, 1, 1))[1]
    This will show partitioning only part of a segment's measures.

18. Add some tests to show this:
        measures = red_segment.select_background_measures('Voice 1')
        middle_third_of_measures = measures.partition_objects_by_ratio((1, 1, 1))[1]
        measure = middle_third_of_measures[:1]
    This will show slice selection following after partition.

19. Add some tests to show this:
        segment = red_segment.select()
        first_half_of_red_segment = segment.divide_by_ratio((1, 1))[0]
        measures = first_half_of_red_segment.select_background_measures('Voice 1')
    This will show background measures that start during the first half of a segment.

20. Audit all selector doc strings and make sure that examples are as compact and modern as possible.
    Also audit to make sure that all selector doc string examples are made with
    reference to instantiated score and segment specifications (rather than initialized by hand).

21. Audit all symbolic timespan docstrings and make sure everything is modern.

22. Extend BackgroundMeasureSelector._get_offsets() to return 
    (start_offset, stop_offset, selected_objects) triple.
    Then extend all selector _get_offsets() methods and do the same.

23. Eventually add something like offset modifications to SymbolicOffset class.
    Modification methods include SymbolicOffset.translate() and possibly others.

24. Can start_segment_identifier properties eventually be completely removed from model?
    What should be possible is for code to look at any symbolic timespan and get start segment specification.
    There is in fact an Interpreter.get_start_segment_specification() method right now.
    How does this relate to the "reanchoring" of settings during interpretation?

25. Eventually remove the sundry interpreter calls to requesttools.apply_request_transforms().
    There should be no reason for paired calls coming one after the other.
    There's got to be some way to completely centralize modifier application.

26. Perhaps Request and Selector need to inherit from a common superclass.
    All such classes implement a certain set of (delayed evaluation) modifications.
    So perhaps there's the idea of a ModificationCarrier somewhere in the object model.

27. Maybe change red_segment.select_background_measures('Voice 1', 0, 1) everywhere
    to red_segment.select_background_measures('Voice 1')[:1] for consistency.
    This will mean removing start=None and stop=None keywords from select() methods.

28. Make Specification aggregate a symbolic timespan rather than inheriting from SymbolicTimespan.

29. Remove definitions of _clone() from system.
    Use correctly implemented deepcopy instead.

30. Looks like modifications stack may not be copied over from segment to segment for persistent settings.
    Fix test_multiple_segment_solo__persistent_overlapping_division_selectors_03() to debug.
