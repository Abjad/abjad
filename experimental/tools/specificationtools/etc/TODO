1. Remove 'series' from 'X series 7' and the like to produce just 'X 7'.
    Even better will be to extend helpertools.write_test_output() to write 'X7 'instead of 'X 7'.
    Also remove 'series' from test file name.

2.  Afford rhythm command request of parseable string. This will make ...
        red_segment.set_rhythm("c'32 [ c'16 c'16. ]", contexts=['Voice 1'])
        voice_1_rhythm_command = red_segment.timespan.start_offset.request_rhythm_command('Voice 1')
        red_segment.set_rhythm(voice_1_rhythm_command, contexts=['Voice 2'])
    ... interpret correctly.
    Then make X5 work with rhythm command request instead of rhythm request.

3.  Author tests to make sure that persistent overlapping division selectors 
    can be overwritten in a subsequent segment.
    See test_multiple_segment_solo__persistent_overlapping_division_selectors_05().

4.  Notice that the SegmentSpecification.set_divisions() 'truncate' keyword means two things.
    It means truncate last division in section. It also means restart divisions at
    beginning of following section. Implement a SegmentSpecification.set_divisions()
    boolean 'restart' keyword to separate these functions. When restart=True
    then truncate will always effectively be interpreted as true.

### ROTATION ###

5.  Extend OffsetPositionedRhythmExpression.rotate() with a new 'level=-1' keyword.
    The keyword will specify the score-tree level at which rotation should happen.
    The keyword will be an attribute of the RotationIndicator class.

6.  Reimplement rhythm rotation to pay attention to the differences beteween
    spanners that cover components and spanners that dominate components.
    Fill in missing spannertools docstrings before doing this.

7.  Extend RotationIndicator to allow for symoblic rotation by portion of total duration.
    Might look like rotation=settingtools.RotationIndicator((-1, 3)).
    Or like rotation=(-1, 3), rotation=(-2, 2), rotation(-3, 1).
    This also suggests a companion procedure that rotates based on ratio of total count of elements.

### MORE ###

8.  Can start_segment_identifier properties eventually be completely removed from model?
    What should be possible is for code to look at any symbolic timespan and get start segment specification.
    There is in fact an Interpreter.get_start_segment_specification() method right now.
    How does this relate to the "reanchoring" of settings during interpretation?

9.  Rename _set_start_segment_identifier().
    Maybe should be called _set_anchor(). Not sure.
    In fact it's possible that the entire notion of "start segment identifier" reduces to "anchor".
    If that turns out to be the case then "start segment specification" is
    something like "anchor segment specification".
    And more generally we have "anchor specification" to allow both score- and segment-anchoring.

10. Implement some sort of "cake slice" management interface on SegmentSpecification and ScoreSpecification.
    Currently we must use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        rhythm = red_segment.select_leaves('Voice 1', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 1'])
        rhythm = red_segment.select_leaves('Voice 2', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 2'])
        rhythm = red_segment.select_leaves('Voice 3', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 3'])
        rhythm = red_segment.select_leaves('Voice 4', timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 4'])
    ... when it might be possible to use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        selected_voices = ['Voice 1', 'Voice 2', 'Voice 3', 'Voice 4']
        rhythm = red_segment.select_leaves(selected_voices, timespan=selector)
        blue_segment.set_rhythm(rhythm, contexts=selected_voices)
    ... instead.
    This will simplify the X9 composer interface.

11. Unskip all experimental tests before 2.11 build.

12. Finish timerelationtools class docstrings before 2.11 build.

13. Finish timespantools package docstrings before 2.11 build.

14. Add examples to the docstrings of all experimental class methods and properties before 2.11 build.

15. Audit to get rid of string-based keys everywhere in interpreter.

16. Extend OffsetExpression with an 'offset_modifiers' stack.
    Modifier methods include OffsetExpression.translate() and possibly others.

17. Extend all selector _get_timespan() methods to return
    (timespan, selected_objects) pair:
        BackgroundMeasureSelector._get_timespan()
        BeatSelector._get_timespan()
        CounttimeComponentSelector._get_timespan()
        DivisionSelector._get_timespan()
        ScoreSelector._get_timespan() ?
        SegmentSelector._get_timespan() ?
    Then possibly rename _get_timespan() to something more descriptive.

18. Is the idea of a 'region command' redundant? Is it the case that all commands
    always define a region? This might be so if all commands always encompass a timespan.
    Probably is redundant. But better to leave the redundancy in place until
    the two different uses of 'command' disambiguate (ie, 'region command' 
    versus 'command request'.)

19. Looks like modifiers stack may not be copied over from segment to segment for persistent settings.
    Fix test_multiple_segment_solo__persistent_overlapping_division_selectors_03() to debug.

20. Add a test to show this:
        note_selector = red_segment.select_notes_and_chords('Voice 1')[10:11]
        offset = note_selector.stop_offset

21. Add some tests to show this:
        measures = red_segment.select_background_measures('Voice 1')
        measures = measures[10:20]
        measures = measures[2:4]
    This will show getitem composition.

22. Add some tests to show this:
        segments = score_specification.select_segments()['red':('blue'+1)]
        middle_part = segments.set_offset(start=(3, 4), stop=(-3, 4))
        score_specification.set_divisions([(1, 16)])
        middle_part.set_divisions([(3, 16)])
    This will show setting divisions for (potentially) more than one segment.

23. Add some tests to show this:
        segments = score_specification.select_segments()['red':('blue'+1)]
        middle_measures = segments.select_background_measures('Voice 1')[3:6]
    This will show selecting background measures from (potentially) more than one segment.

24. Add some tests to show this:
        measures = red_segment.select_background_measures('Voice 1')[10:20]
        middle_third_of_measures = measures.partition_by_ratio((1, 1, 1))[1]
    This will show partitioning only part of a segment's measures.

25. Add some tests to show this:
        measures = red_segment.select_background_measures('Voice 1')
        middle_third_of_measures = measures.partition_by_ratio((1, 1, 1))[1]
        measure = middle_third_of_measures[:1]
    This will show slice selection following partition.

26. Add some tests to show this:
        first_half_of_red_segment = red_segment.timespan.divide_by_ratio((1, 1))[0]
        measures = first_half_of_red_segment.select_background_measures('Voice 1')
    This will show selecting background measures that start during a duration-partitioned part of segment.

27. Rename Request to RequestMethodMixin to parallel SetMethodMixin.

28. Author tests to show each request modifier applied to each selector.
    Remaining tests to author:
        leaves.__getitem__()
        leaves.partition_by_ratio()
        leaves.partition_by_ratio_of_durations()
        leaves.repeat_to_duration()
        leaves.repeat_to_length()
        leaves.reverse()
        leaves.rotate()

29. Relace Command.offsets with Command.timespan.

30. Implement Command.set(request=divisions).

31. Rename select test collateral with 'select'.
    The files are these:
        test_ScoreSpecification_request_rhythm.py
        test_SegmentSpecification__request_divisions_between_voices.py
        test_SegmentSpecification__request_divisions_from_future.py
        test_SegmentSpecification__request_divisions_from_future_between_voices.py
        test_SegmentSpecification__request_divisions_from_past.py
        test_SegmentSpecification__request_divisions_from_past_between_voices.py
        test_SegmentSpecification__request_rhythm_between_voices.py
        test_SegmentSpecification__request_rhythm_from_future.py
        test_SegmentSpecification__request_rhythm_from_future_between_voices.py
        test_SegmentSpecification__request_rhythm_from_past.py
        test_SegmentSpecification__request_rhythm_from_past_between_voices.py
        test_SegmentSpecification__request_time_signatures_from_future.py
        test_SegmentSpecification__request_time_signatures_from_past.py
    All collateral should rename.
