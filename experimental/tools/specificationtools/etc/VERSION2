1.  Change SelectMethodMixin.select_leaves() to SelectoMethodMixin.select_rhythm().
    Implement SelectMethodMixin.select_rhythm(depth=-1) keyword

2.  Overwrite existing divisions with new divisions:
        divisions = red_segment.select_divisions('Voice 1')[5:10]
        red_segment.set_divisions([(2, 16)], timespan=divisions)
    (Note that overwriting existing time signatures with new time signatures makes no sense.)

3.  Overwrite existing rhythms with new rhythms:
        leaves = red_segment.select_leaves('Voice 1')[5:10]
        red_segment.set_rhythm(library.thirty_seconds, timespan=leaves)

4.  Create leaves somewhere.
    Then select a slice of leaves.
    Then overwrite that slice with a different rhythm-maker.

5.  Implement voice intermittency.

### ROTATION ###

6. Implement TimespanInventory.rotate(Duration(-4, 1)).

7.  Extend StartPositionedRhythmPayloadExpression.rotate() with a new 'level=-1' keyword.
    The keyword will specify the score-tree level at which rotation should happen.
    The keyword will be an attribute of the RotationIndicator class.

8.  Reimplement rhythm rotation to pay attention to the differences beteween
    spanners that cover components and spanners that dominate components.
    Fill in missing spannertools docstrings before doing this.

9.  Extend RotationIndicator to allow for symoblic rotation by portion of total duration.
    Might look like rotation=settingtools.RotationIndicator((-1, 3)).
    Or like rotation=(-1, 3), rotation=(-2, 2), rotation(-3, 1).
    This also suggests a companion procedure that rotates based on ratio of total count of elements.
