1.  Author tests to make sure that persistent overlapping division selectors 
    can be overwritten in a subsequent segment.
    See test_multiple_segment_solo__persistent_overlapping_division_selectors_05().

2.  Notice that the SegmentSpecification.set_divisions() 'truncate' keyword means two things.
    It means truncate last division in section. It also means restart divisions at
    beginning of following section. Implement a SegmentSpecification.set_divisions()
    boolean 'restart' keyword to separate these functions. When restart=True
    then truncate will always effectively be interpreted as true.

3.  Extend OffsetPositionedRhythmExpression.rotate() with a new 'level=-1' keyword.
    The keyword will specify the score-tree level at which rotation should happen.
    The keyword will be an attribute of the RotationIndicator class.

4.  Afford rhythm command request of parseable string. This will make ...
        red_segment.set_rhythm("c'32 [ c'16 c'16. ]", contexts=['Voice 1'])
        voice_1_rhythm_command = red_segment.request_rhythm_command('Voice 1')
        red_segment.set_rhythm(voice_1_rhythm_command, contexts=['Voice 2'])
    ... interpret correctly.
    Then make X5 work with rhythm command request instead of rhythm request.

5.  Reimplement rhythm rotation to pay attention to the differences beteween
    spanners that cover components and spanners that dominate components.
    Fill in missing spannertools docstrings before doing this.

6.  Write D series schematic examples to (re)establish metrical hierarhcy at two different points.
    Establish metrical hierarchy after division specification and change divisions where necessary.
    Reestablish metrical hierarchy after rhythm specification but leave divisions in tact.

7.  Write E series schematic examples to all focus on different uses of the metrical hierarchy.
    Set divisions equal to different levels of the metrical hierarchy (beat, next level down, etc.).
    Make selections equal to different levels of the metrical hierarchy.

8.  Find a way to make beam_cells_together a rhythm-maker initializer keyword. 
    Right now it's added onto the side of already-initialized
    rhythm-makers in the rhythm library. Better to add to the rhythm-maker initializer signature.

9.  Write reverse() tests for all rhythm-makers.

10. Write rotate() tests for all rhythm-makers.

11. Finish timerelationtools class docstrings before 2.11 build.

12. Change DivisionSymbolicTimespan.get_selected_objects() to return a Selection object.
    Change CounttimeComponentSymbolicTimespan.get_selected_objects() to return a Selection object.
    Change other selectors' get_selected_objects() to return a Selection object.

13. Author tests to show selecting leaves that don't yet exist.
    Make sure the command is ignored at first and then interpreted correctly in a later pass.

14. Audit to get rid of string-based keys everywhere in interpreter.

15. Add examples to the docstrings of all experimental class methods and properties before 2.11 build.

16. Implement selections pervasively before renaming (score tree-mutating) componenttools functions.
    The reason is because selection implementation may clarify the names of certain operations.

17. Remove 'series' from 'X series 7' and the like to produce just 'X 7'.
    Even better will be to extend helpertools.write_test_output() to write 'X7 'instead of 'X 7'.
    Also remove 'series' from test file name.

18. Unskip all experimental tests before 2.11 build.

19. Implement a TreatmentSpecifier class.
    This will clean up some classes and make treatment-to-treatment comparison cleaner.
    This will also clean up the initializers of all request classes:
        requesttools.AbsoluteRequest
        requesttools.CommandRequest
        requesttools.HandlerRequest
        requesttools.MaterialRequest
        requesttools.StatalServerRequest
    This will also clean up the API entries of all request classes.
    Note that this will leave the five independent keywords in the request *methods*.
    (So this item cleans up request classes and leaves flexibility in composer specification *methods*.)

20. Remove these select methods:
        SegmentSpecification.select_ratio_of_background_measures()
        SegmentSpecification.select_ratio_of_divisions()
        SegmentSpecification.select_ratio_of_leaves()
        SegmentSpecification.select_ratio_of_notes_and_chords()
        SegmentSpecification.select_segment_ratio()
    Add these select methods:
        SegmentSpecification.select_count_ratio_part()
        SegmentSpecification.select_time_ratio_part()

21. Write voice-anchored selector tests.

22. Make most DivisionIncisedNoteRhythmMaker initializer parameters optional.
    Right now prefix_talea, prefix_lengths, suffix_talea, suffix_lengths and
    talea_denominator are all mandatory. Cleaner is all are optional
    and the class defaults to unincised note-making behavior.

23. Extend RotationIndicator to allow for symoblic rotation by portion of total duration.
    Might look like rotation=settingtools.RotationIndicator((-1, 3)).
    Or like rotation=(-1, 3), rotation=(-2, 2), rotation(-3, 1).
    This also suggests a companion procedure that rotates based on ratio of total count of elements.

24. Implement some sort of "cake slice" management interface on SegmentSpecification and ScoreSpecification.
    Currently we must use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        rhythm = red_segment.request_rhythm('Voice 1', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 1'])
        rhythm = red_segment.request_rhythm('Voice 2', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 2'])
        rhythm = red_segment.request_rhythm('Voice 3', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 3'])
        rhythm = red_segment.request_rhythm('Voice 4', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 4'])
    ... when it might be possible to use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        selected_voices = ['Voice 1', 'Voice 2', 'Voice 3', 'Voice 4']
        rhythm = red_segment.request_rhythm(selected_voices, selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=selected_voices)
    ... instead.
    This will simplify the X9 composer interface.

25. Maybe rename selector classes to symbolic timespan classes?
        So BackgroundMeasureSymbolicTimespan ==> BackgroundMeasureSymbolicTimespan
    Maybe this also means migrating all selectortools classes into symbolictimetools?
    This would remove the selectortools package altogether.
        
26. Maybe extend all segment and score specification request methods with time_relation=None keyword.
    The methods in question are:
        Specification.request_divisions()
        Specification.request_naive_beats()
        Specification.request_partitioned_total_time()
        Specification.request_rhythm()
        Specification.request_time_signatures()
    This would make request methods parallel select methods.
    And, actually, this might obviate the ned for select methods to carry a time_relation keyword.
    If select methods always select (pure) timespans then selecto methods will need no time_relation keyword.

27. Maybe the above action items point to removing the concept of the selector from the system.
    A selector is a (timespan, time_relation) pair.
    Maybe it's better to pass timespans and time_relations around independently.
    That will mean that every select method (without exception) will return a pure timespan.
    This will also mean that every method that currently takes a 'selector' keyword
    will in future take both a 'timespan' keyword and a 'time_relation' keyword;
    and it should be all (and only) the request() and set() methods that take
    both a 'timespan' keyword and a 'time_relation' keyword.
    This should also mean that the selectortools package truly could be eliminated.
    Why? Because each class in selectortools would represent a pure symbolic timespan.
    All such classes should then migrate into symoblictimetools.

28. Why doesn't MaterialRequest feature a time_relation property?
    Should MaterialRequest('divisions', timespan, context_name=voice)
    be MaterialRequest('division', timespan, time_relation, context_name=voice) instead?
    Probably because timespan is currently a selector.
    Selector is currently a (timespan, time_relation).
    See item above to unbundle selector and carry around timespans and time relations independently.
    So an incremental way to approach item immediately above is to work this item first.
    What will that mean?
    It will mean changing MaterialRequest to feature independent timespan and time_relation properties.

29. The notion of "start segment" is incompletely worked out in the current impelementation.
    What is that part of the model trying to point to?
    I think it's pointing to the idea that every symbolic timespans is "anchored" to something.
    To what does a symbolic timespan anchor? Either a (named) segment or else to the entire score.
    This is born out by looking at the examples given in the symbolic timespan doc strings;
    the examples all say "... in segment 'red'" or '... in the score'.
    Should symbolic timespans model independently of such an anchor? 
    I suppose that's a possibility. But it seems highly unlikely to improve the object model.
    Such an unanchored symbolic timespan could be anchored repeatedly to different anchors.
    "Select the first three divisions ... first of segment red ... now of segment blue."
    If this turns out to be required then a dedicated method should implement in the composer interface.

30. TimeRelationSymbolicTimespan now inherits from SliceSymbolicTimespan.
    Is it possible to remove SliceSymbolicTimespan altogether?
    Looks like the answer to this one is that the two classes can in fact compress into one.
    But leave both classes in the system for a bit to see if other symbolic timespan changes change this.

31. Rename OffsetSymbolicTimespan 'selector' property to 'anchor'.
    Eventually rename CounttimeComponentSymbolicTimespan 'selector' property 'anchor'.
