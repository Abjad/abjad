1. Remove 'series' from 'X series 7' and the like to produce just 'X 7'.
    Even better will be to extend helpertools.write_test_output() to write 'X7 'instead of 'X 7'.
    Also remove 'series' from test file name.

2.  Afford rhythm command request of parseable string. This will make ...
        red_segment.set_rhythm("c'32 [ c'16 c'16. ]", contexts=['Voice 1'])
        voice_1_rhythm_command = red_segment.request_rhythm_command('Voice 1')
        red_segment.set_rhythm(voice_1_rhythm_command, contexts=['Voice 2'])
    ... interpret correctly.
    Then make X5 work with rhythm command request instead of rhythm request.

3.  Author tests to make sure that persistent overlapping division selectors 
    can be overwritten in a subsequent segment.
    See test_multiple_segment_solo__persistent_overlapping_division_selectors_05().

4.  Notice that the SegmentSpecification.set_divisions() 'truncate' keyword means two things.
    It means truncate last division in section. It also means restart divisions at
    beginning of following section. Implement a SegmentSpecification.set_divisions()
    boolean 'restart' keyword to separate these functions. When restart=True
    then truncate will always effectively be interpreted as true.

### ROTATION ###

5.  Extend OffsetPositionedRhythmExpression.rotate() with a new 'level=-1' keyword.
    The keyword will specify the score-tree level at which rotation should happen.
    The keyword will be an attribute of the RotationIndicator class.

6.  Reimplement rhythm rotation to pay attention to the differences beteween
    spanners that cover components and spanners that dominate components.
    Fill in missing spannertools docstrings before doing this.

7.  Extend RotationIndicator to allow for symoblic rotation by portion of total duration.
    Might look like rotation=settingtools.RotationIndicator((-1, 3)).
    Or like rotation=(-1, 3), rotation=(-2, 2), rotation(-3, 1).
    This also suggests a companion procedure that rotates based on ratio of total count of elements.

### MORE ###

8.  Finish timerelationtools class docstrings before 2.11 build.

9.  Author tests to show selecting leaves that don't yet exist.
    Make sure the command is ignored at first and then interpreted correctly in a later pass.

10. Audit to get rid of string-based keys everywhere in interpreter.

11. Add examples to the docstrings of all experimental class methods and properties before 2.11 build.

12. Unskip all experimental tests before 2.11 build.

13. Implement some sort of "cake slice" management interface on SegmentSpecification and ScoreSpecification.
    Currently we must use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        rhythm = red_segment.request_rhythm('Voice 1', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 1'])
        rhythm = red_segment.request_rhythm('Voice 2', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 2'])
        rhythm = red_segment.request_rhythm('Voice 3', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 3'])
        rhythm = red_segment.request_rhythm('Voice 4', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 4'])
    ... when it might be possible to use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        selected_voices = ['Voice 1', 'Voice 2', 'Voice 3', 'Voice 4']
        rhythm = red_segment.request_rhythm(selected_voices, selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=selected_voices)
    ... instead.
    This will simplify the X9 composer interface.

14. Remove these symbolictimetools classes:
        symbolictimetools.CountRatioOperator
        symbolictimetools.TimeRatioOperator
    Replace with this bound methods:
        selector.partition_by_ratio()
        selector.partition_by_time_weighted_ratio()
    Methods must be preserved as strings to delay evaluation.
    Then remove symbolictimetools.RatioOperator.

15. Remove the three command request methods:
        Specification.request_division_command()
        Specification.request_rhythm_command()
        Specification.request_time_signature_command()
    The commands currently take selector=None, edge=None, multiplier=None, addendum=None keywords.
    Better to implement a small number of methods as necessary in the system.
    These methods will enable composers to create exactly the correct symbolic offset.
    Then implement these symbolic offset bound methods:
        SymbolicOffset.request_division_command(voice)
        SymbolicOffset.request_rhythm_command(voice)
        SymbolicOffset.request_time_signature_command(voice)

16. Remove Request index=None, count=None, reverse=None, rotation=None, callback=None treatment keywords.
    Replace these with methods bound to Request that return annotated request.
    This will parallel the methods bound to symbolic timespans that return wrapped symbolic timespans.
    This will also mean that any number of arbitrary transforms may be applied to a request in any order.
    This will probably also eliminate the two-stage setting (and interpretation) of request treatments.

17. I think it's quite likely that selection and request-making are going to turn out to be the same thing.
    What does it fundamentally mean to select something?
    We say "select <something> <that starts during> <(the timespan of) segment 'red'>".
    Any time we reference the timespan of something we need to afford a time_relation=None keyword.
    This happens the exact same way in both select() and request() methods.
    So this action item probably means to remove all request() methods in favor of select() methods.

18. Should there be an intermediate VoiceSelector class?

19. Change in-place segment.adjust_offsets() to return a modified copy of segment instead.

20. Add some tets to show this:
        middle_part = score_specification.select_segments('red', ('blue' + 1))
        middle_part.adjust_offsets(start=(3, 4), stop=(-3, 4))
        score_specification.set_divisions([(1, 16)])
        score_specification.set_divisions([(3, 16)], selector=middle_part)
    This will show anchoring to a segment selector that selects more than one segment.
