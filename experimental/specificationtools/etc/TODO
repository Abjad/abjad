1. Remove 'series' from 'X series 7' and the like to produce just 'X 7'.
    Even better will be to extend helpertools.write_test_output() to write 'X7 'instead of 'X 7'.
    Also remove 'series' from test file name.

2.  Afford rhythm command request of parseable string. This will make ...
        red_segment.set_rhythm("c'32 [ c'16 c'16. ]", contexts=['Voice 1'])
        voice_1_rhythm_command = red_segment.request_rhythm_command('Voice 1')
        red_segment.set_rhythm(voice_1_rhythm_command, contexts=['Voice 2'])
    ... interpret correctly.
    Then make X5 work with rhythm command request instead of rhythm request.

3.  Author tests to make sure that persistent overlapping division selectors 
    can be overwritten in a subsequent segment.
    See test_multiple_segment_solo__persistent_overlapping_division_selectors_05().

4.  Notice that the SegmentSpecification.set_divisions() 'truncate' keyword means two things.
    It means truncate last division in section. It also means restart divisions at
    beginning of following section. Implement a SegmentSpecification.set_divisions()
    boolean 'restart' keyword to separate these functions. When restart=True
    then truncate will always effectively be interpreted as true.

### ROTATION ###

5.  Extend OffsetPositionedRhythmExpression.rotate() with a new 'level=-1' keyword.
    The keyword will specify the score-tree level at which rotation should happen.
    The keyword will be an attribute of the RotationIndicator class.

6.  Reimplement rhythm rotation to pay attention to the differences beteween
    spanners that cover components and spanners that dominate components.
    Fill in missing spannertools docstrings before doing this.

7.  Extend RotationIndicator to allow for symoblic rotation by portion of total duration.
    Might look like rotation=settingtools.RotationIndicator((-1, 3)).
    Or like rotation=(-1, 3), rotation=(-2, 2), rotation(-3, 1).
    This also suggests a companion procedure that rotates based on ratio of total count of elements.

### MORE ###

8.  Finish timerelationtools class docstrings before 2.11 build.

9.  Change DivisionSymbolicTimespan.get_selected_objects() to return a Selection object.
    Change CounttimeComponentSymbolicTimespan.get_selected_objects() to return a Selection object.
    Change other selectors' get_selected_objects() to return a Selection object.

10. Author tests to show selecting leaves that don't yet exist.
    Make sure the command is ignored at first and then interpreted correctly in a later pass.

11. Audit to get rid of string-based keys everywhere in interpreter.

12. Add examples to the docstrings of all experimental class methods and properties before 2.11 build.

13. Unskip all experimental tests before 2.11 build.

14. Implement some sort of "cake slice" management interface on SegmentSpecification and ScoreSpecification.
    Currently we must use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        rhythm = red_segment.request_rhythm('Voice 1', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 1'])
        rhythm = red_segment.request_rhythm('Voice 2', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 2'])
        rhythm = red_segment.request_rhythm('Voice 3', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 3'])
        rhythm = red_segment.request_rhythm('Voice 4', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 4'])
    ... when it might be possible to use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        selected_voices = ['Voice 1', 'Voice 2', 'Voice 3', 'Voice 4']
        rhythm = red_segment.request_rhythm(selected_voices, selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=selected_voices)
    ... instead.
    This will simplify the X9 composer interface.

15. TimeRelationSymbolicTimespan now inherits from SliceSymbolicTimespan.
    Is it possible to remove SliceSymbolicTimespan altogether?
    Looks like the answer to this one is that the two classes can in fact compress into one.
    But leave both classes in the system for a bit to see if other symbolic timespan changes change this.

16. Rename OffsetSymbolicTimespan 'selector' property to 'anchor'.
    Eventually rename CounttimeComponentSymbolicTimespan 'selector' property 'anchor'.

17. Change ...
        symbolictimetools.CountRatioPartSymbolicTimespan(
            symbolictimetools.BackgroundMeasureSymbolicTimespan(
                anchor='red'
                ),
            mathtools.Ratio(1, 1, 1),
            2
            )
    ... to ...
        symbolictimetools.CountRatioPartSymbolicTimespan(
            anchor=symbolictimetools.BackgroundMeasureSymbolicTimespan(
                anchor='red'
                ),
            mathtools.Ratio(1, 1, 1),
            2
            )
    ... to show that ratio part symbolic timespans have an anchor.

18. Implement a TreatmentSpecifier class.
    This will clean up some classes and make treatment-to-treatment comparison cleaner.
    This will also clean up the initializers of all request classes:
        requesttools.AbsoluteRequest
        requesttools.CommandRequest
        requesttools.HandlerRequest
        requesttools.MaterialRequest
        requesttools.StatalServerRequest
    This will also clean up the API entries of all request classes.
    Note that this will leave the five independent keywords in the request *methods*.
    (So this item cleans up request classes and leaves flexibility in composer specification *methods*.)
    This action item may be obviated by the introduction of methods bound to the Request class.

19. Remove Request index=None, count=None, reverse=None, rotation=None, callback=None treatment keywords.
    Replace these with methods bound to Request that return annotated request.
    This will parallel the methods bound to symbolic timespans that return wrapped symbolic timespans.
    This will also mean that any number of arbitrary transforms may be applied to a request in any order.
    This will probably also eliminate the two-stage setting (and interpretation) of request treatments.
    This will probably also eliminate the action item to implement a Treatment class.

20. Write voice-anchored selector tests.
    Maybe all selectors should be voice anchored. 
    (Except background measures, etc.)

21. Extend all specification request methods with time_relation=None keyword.
    The methods in question are:
        Specification.request_divisions()
        Specification.request_naive_beats()
        Specification.request_partitioned_total_time()
        Specification.request_rhythm()
        Specification.request_time_signatures()
    This is the right thing to do because all requests are made against an (anchor) timespan.
    The default relation to that (anchor) timespan is assumed to be "happens during anchor".
    The time_relation=None lets the composer specify the time relation of request to anchor.
    This action item may be obviated if request methods are removed in favor of select methods.

22. I think it's quite like that selection and request-making are going to turn out to be the same thing.
    What does it fundamentally mean to select something?
    We say "select <something> <that starts during> <(the timespan of) segment 'red'>".
    Any time we reference the timespan of something we need to afford a time_relation=None keyword.
    This happens the exact same way in both select() and request() methods.
    So this action item probably means to remove all request() methods in favor of select() methods.

23. Change MaterialRequest.context_name to MaterialRequest.voice_name.
    Because materials exist only within a single voice.
