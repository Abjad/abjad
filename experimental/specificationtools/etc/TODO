1. Remove 'series' from 'X series 7' and the like to produce just 'X 7'.
    Even better will be to extend helpertools.write_test_output() to write 'X7 'instead of 'X 7'.
    Also remove 'series' from test file name.

2.  Afford rhythm command request of parseable string. This will make ...
        red_segment.set_rhythm("c'32 [ c'16 c'16. ]", contexts=['Voice 1'])
        voice_1_rhythm_command = red_segment.request_rhythm_command('Voice 1')
        red_segment.set_rhythm(voice_1_rhythm_command, contexts=['Voice 2'])
    ... interpret correctly.
    Then make X5 work with rhythm command request instead of rhythm request.

3.  Author tests to make sure that persistent overlapping division selectors 
    can be overwritten in a subsequent segment.
    See test_multiple_segment_solo__persistent_overlapping_division_selectors_05().

4.  Notice that the SegmentSpecification.set_divisions() 'truncate' keyword means two things.
    It means truncate last division in section. It also means restart divisions at
    beginning of following section. Implement a SegmentSpecification.set_divisions()
    boolean 'restart' keyword to separate these functions. When restart=True
    then truncate will always effectively be interpreted as true.

### ROTATION ###

5.  Extend OffsetPositionedRhythmExpression.rotate() with a new 'level=-1' keyword.
    The keyword will specify the score-tree level at which rotation should happen.
    The keyword will be an attribute of the RotationIndicator class.

6.  Reimplement rhythm rotation to pay attention to the differences beteween
    spanners that cover components and spanners that dominate components.
    Fill in missing spannertools docstrings before doing this.

7.  Extend RotationIndicator to allow for symoblic rotation by portion of total duration.
    Might look like rotation=settingtools.RotationIndicator((-1, 3)).
    Or like rotation=(-1, 3), rotation=(-2, 2), rotation(-3, 1).
    This also suggests a companion procedure that rotates based on ratio of total count of elements.

### MORE ###

8.  Finish timerelationtools class docstrings before 2.11 build.

9.  Author tests to show selecting leaves that don't yet exist.
    Make sure the command is ignored at first and then interpreted correctly in a later pass.

10. Audit to get rid of string-based keys everywhere in interpreter.

11. Add examples to the docstrings of all experimental class methods and properties before 2.11 build.

12. Unskip all experimental tests before 2.11 build.

13. Implement some sort of "cake slice" management interface on SegmentSpecification and ScoreSpecification.
    Currently we must use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        rhythm = red_segment.request_rhythm('Voice 1', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 1'])
        rhythm = red_segment.request_rhythm('Voice 2', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 2'])
        rhythm = red_segment.request_rhythm('Voice 3', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 3'])
        rhythm = red_segment.request_rhythm('Voice 4', selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=['Voice 4'])
    ... when it might be possible to use ...
        selector = red_segment.select_segment_offsets(Offset(3, 16), Offset(6, 16))
        selected_voices = ['Voice 1', 'Voice 2', 'Voice 3', 'Voice 4']
        rhythm = red_segment.request_rhythm(selected_voices, selector=selector)
        blue_segment.set_rhythm(rhythm, contexts=selected_voices)
    ... instead.
    This will simplify the X9 composer interface.

14. Remove the three command request methods:
        Specification.request_division_command()
        Specification.request_rhythm_command()
        Specification.request_time_signature_command()
    The commands currently take selector=None, edge=None, multiplier=None, addendum=None keywords.
    Better to implement a small number of methods as necessary in the system.
    These methods will enable composers to create exactly the correct symbolic offset.
    Then implement these symbolic offset bound methods:
        SymbolicOffset.request_division_command(voice)
        SymbolicOffset.request_rhythm_command(voice)
        SymbolicOffset.request_time_signature_command(voice)

15. Remove Request index=None, count=None, reverse=None, rotation=None, callback=None treatment keywords.
    Replace these with methods bound to Request that return annotated request.
    This will parallel the methods bound to symbolic timespans that return wrapped symbolic timespans.
    This will also mean that any number of arbitrary transforms may be applied to a request in any order.
    This will probably also eliminate the two-stage setting (and interpretation) of request treatments.

16. I think it's quite likely that selection and request-making are going to turn out to be the same thing.
    What does it fundamentally mean to select something?
    We say "select <something> <that starts during> <(the timespan of) segment 'red'>".
    Any time we reference the timespan of something we need to afford a time_relation=None keyword.
    This happens the exact same way in both select() and request() methods.
    So this action item probably means to remove all request() methods in favor of select() methods.

17. These two selectors should implement an initializer that forces a voice_name attribute:
        CounttimeComponentSelector
        DivisionSelector
    The other selectors should implement initializers that do not allow a voice_name attribute at all.

18. Add some tests to show this:
        measures = red_segment.select_background_measures(10, 20)
        measures = measures.select(2, 4)
    This will show the composition of multiple slice selections in a row.

19. Add some tets to show this:
        segments = score_specification.select_segments('red', ('blue' + 1))
        middle_part = segments.adjust_timespan_offsets(start=(3, 4), stop=(-3, 4))
        score_specification.set_divisions([(1, 16)])
        score_specification.set_divisions([(3, 16)], selector=middle_part)
    This will show anchoring to a segment selector that selects more than one segment.

20. Add some tests to show this:
        segments = score_specification.select_segments('red', ('blue' + 1))
        middle_measures = segments.select_background_measures(3, 6)
    This will show selecting background measures from more than one segment.

21. Add some tests to show this:
        measures = red_segment.select_background_measures(10, 20)
        middle_third_of_measures = measures.partition_by_ratio((1, 1, 1))[1]
    This will show partitioningonly part of a segment's measures.

22. Add some tests to show this:
        measures = red_segment.select_background_measures()
        middle_third_of_measures = measures.partition_by_ratio((1, 1, 1))[1]
        measure = middle_third_of_measures.select(0, 1)
    This will show slice selection following after partition.

23. Can start_segment_identifier properties eventually be completely removed from model?

24. Audit all selector doc strings and make sure that examples are as compact and modern as possible.
    Also audit to make sure that all selector doc string examples are made with
    reference to instantiated score and segment specifications (rather than initialized by hand).

25. Audit all symbolic timespan docstrings and make sure everything is modern.

26. Implement a TimeRelation predicate to test whether the time relation is fully *unloaded*.
    Then use this test to make sure that time relations passed into all selectors
    everywhere in the system are fully unloaded.

27. Remove BackgroundMeasureSelector.get_selected_objects().
    Extend BackgroundMeasureSelector.get_offsets() to return (start_offset, stop_offset, selected_objects)
    instead.
    Then audit all selectors, implement get_selected_objects, and write at least one test for each method.
    Or else audit all selector and remove get_selected_objects() method for each selector.

28. Store offset modifications in inventory class that indents in storage format.

29. Eventually add something like offset modifications to SymbolicOffset class.

30. Make it possible to say red_segment.adjust_timespan_offsets() and red_segment.divide_timespan_by_ratio().

31. Add the following timespan modification methods:
        timespan.scale_timespan(multiplier)
        timespan.set_timespan_duration(duration)
        timespan.set_timespan_start_offset(offset)
        timespan.set_timespan_stop_offset(offset)
        timespan.translate_timespan(duration)
    These may be enough to make the timespan modification inventory complete for first release.
