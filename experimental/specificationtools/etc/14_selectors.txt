SELECTORS.


The purpose of this document is to list some of the different types of symbolic selection.
What is a symbolic selection? An indication to pick out a score object at some point
during interpretation. Or an indication to pick out a collection of related score objects.


*ScoreElementSelector.* Select a single score object. What input parameters are available?
First, an optional timepsan defaulting to that of the entire score. Second, an optional
timespan inequality defaulting to the first object that starts during timespan. Then an
arbitrarily long list of ContainerIndicator objects which might eventually be implemented
as a ContainerIndicatorList.

Select the first depth-0 tuplet in the last measure starting during segment 'red':

    selector = ScoreElementSelector(
        timespan=Timespan(klass=Division, name='red'),
        comparator=specificationtools.starts_during_timespan(),
        containment=[
            ContainmentIndicator(klass=Measure, index=-1),
            ContainmentIndicator(klass=Tuplet, index=0, depth=0)]

(Possibly better named ComponentSelector to contrast with BackgroundElementSelector.)


*BackgroundElementSelector.* Use to select exactly one background object. Input parameters?
First, an optional timepsan defaulting to that of the entire score. Second, an optional
timespan inequality defaulting to the first object starting during timespan. Then a class.
together with a value set to either an integer index or name.

Segment 'red':

    BackgroundElementSelector(Segment, 'red')

First, last segment starting during score:

    BackgroundElementSelector(Segment, 0)
    BackgroundElementSelector(Segment, -1)

First, last measure starting during score:

    BackgroundElementSelector(Measure, 0)
    BackgroundElementSelector(Measure, -1)

First, last measure starting during segment 'red':

    red = BackgroundElementSelector(Segment, 'red')
    BackgroundElementSelector(Measure, timespan=red.timespan, 0)
    BackgroundElementSelector(Measure, timespan=red.timespan, -1)

First, last measure ending during segment 'red':

    inequality = timespantools.expr_stops_during_timespan()
    BackgroundElementSelector(Measure, timespan=red.timespan, inequality=inequality, 0)
    BackgroundElementSelector(Measure, timespan=red.timespan, inequality=inequality, -1)

First measure overlapping the start but not the stop of segment 'red':

    inequality = timespantools.expr_overlaps_start_of_timespan_only()
    BackgroundElementSelector(Measure, timespan=red.timespan, inequality=inequality, 0)

First measure overlapping the stop but not the start of segment 'red':
    
    inequality = timespantools.expr_overlaps_stop_of_timespan_only()
    BackgroundElementSelector(Measure, timespan=red.timespan, inequality=inequality, 0) 


*SliceSelector.* Select zero or more container elements in sequence. Input parameters?
First, an optional ContainerIndicator defaulting to the entire score. Then, optional
start and stop indices each defaulting to none. The design goal is to mimic the Python
slice interface as closely as possible. So only integer values and none are allowed.
Sequences of named objects like segments will have to be selected some other way.

Select the last three elements of the tuplet picked out above:

    SliceSelector(container=selector, start=-3)


#*IterationFromIndicator.* Select zero or more score objects iterated from a reference object.
#Input parameters? First, an optional reference object indicator defaulting to the entire score.
#Then an optional integer number of consecutive score objects to select, defaulting to 1.
#
#Select the three segments starting with 'red':
#
#    selector = ScoreElementSelector(
#        timespan=Timespan(klass=Division, name='red'),
#        comparator=specificationtools.starts_during_timespan(),
#        containment=[
#            ContainmentIndicator(klass=Measure, index=-1),
#            ContainmentIndicator(klass=Tuplet, index=0, depth=0)]
